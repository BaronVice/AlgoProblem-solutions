import re
""" 1) Что имеется? Есть значит линия из зданий. Часть зданий заминирована. Есть сапер и он может:
 заминировать здание (стоимость b) и взорвать заминированное здание (стоимость a). При взрыве здания
 соседние заминированные здания также взрываются (такой вот эффект домино)
    2) Что надо сделать? Заплатить саперу как можно меньше, чтобы в линии не осталось заминированных зданий.
    3) Что можно заметить? Получается, что линия из 1 - это отрезок, который за стоимость a можно убрать.
 Еще есть вариант соединить два отрезка за стоимость b * n (где n - количество не заминированных между ними
 зданий) и взорвать за a. При условии, что b * n < a, этот вариант более выгодный. Поскольку в этом случае
 стоимость сноса отдельно двух отрезков выйдет дороже (2a), чем их соединение и последующий снос (a + b * n) """


def main():
    a, b = map(int, input().split())
    # Лидирующие и замыкающие нули никак не влияют на задачу. Они будут мешать нам при применении инструментов,
    # поэтому сносим их
    s = input().strip('0')
    # Особый случай: если не было заминированных зданий, то у нас пустая строка. Применять операции на пустой
    # строке не всегда безопасно. Так что скажем, что если город не заминирован, то сапер ничего не получит
    if len(s) == 0:
        return 0

    # Определяем какое количество не заминированных зданий можно соединить, чтобы вышло дешевле, чем взрывать
    # отрезки отдельно
    when_b_is_better = a // b
    # Затем надо посчитать количество сегментов из 0, которые будет выгодно сделать соединителями между заминированными
    # зданиями. Это можно сделать через цикл while - считываем сегменты из 0, находим выгодные и считаем их стоимость.

    # Но мне лень это писать. Проще прикрутить регулярку, которая сама за меня все сделает. Что здесь происходит?
    # Сперва я забираю вообще все отрезки из нулей, используя сплит, который за разделитель принимает любую
    # последовательность единиц (1+ - '1' от одной и больше)
    all_segments = list(re.split("1+", s))
    # Затем выбираю те, которые будет выгодно взять
    segments_we_want_to_connect = list(el for el in all_segments if len(el) <= when_b_is_better)
    # И считаю результат. Сперва стоимость за подрывы отрезков: умножаю 'a' на разность количества всех сегментов из 0
    # и выгодных сегментов из 0 (определяю сколько нужно подорвать после соединения). Количество отрезков из единиц
    # на 1 больше, чем из нулей - прибавляю один. Затем ищу затраты на соединения отрезков (сумма всех длин * b).
    return a * (len(all_segments) - len(segments_we_want_to_connect) + 1) + \
        sum(len(el) * b for el in segments_we_want_to_connect)


if __name__ == "__main__":
    for _ in range(int(input())):
        print(main())

