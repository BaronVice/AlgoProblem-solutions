# Идея задачи: сумма первых k наибольших элементов и есть максимально возможная полезность.
# Количество задач на каждый день будем вычислять так: идем от левого указателя (изначально
# по индексу -1) до тех пор, пока не дойдем до какого-нибудь элемента в максимумах. После того,
# как дошли до такого элемента, считаем длину отрезка от левого указателя до текущего индекса,
# вычеркиваем найденный элемент из максимумов, перемещаем левый указатель на текущий индекс.
# Повторяем процесс, пока в максимумах есть элементы. Как только они закончаться, прибавляем
# к последнему дню оставшиеся справа задачи 

n, k = map(int, input().split())
problems = list(map(int, input().split()))

# Максимумы - первые k наибольших элементов
maximums = sorted(problems, reverse=True)[:k]
# Также их сумма - это максимальная общая полезность
print(sum(maximums))

# Начало отрезка
left_pointer = -1
# Конец отрезка
right_pointer = 0

# Пока в максимумах есть элементы
while maximums:
    # Если текущий элемент лежит в максимумах
    if problems[right_pointer] in maximums:
        # Удаляем элемент из максимумов
        maximums.remove(problems[right_pointer])
        # Если в максимумах больше нет элементов
        if not maximums:
            # То это последний день, прибавляем к нему оставшиеся справа задачи
            print(right_pointer - left_pointer + n - right_pointer - 1)
        else:
            # Иначе считаем длину текущего отрезка
            print(right_pointer - left_pointer, end = " ")
            # И двигаем левый указатель на текущую позицию
            left_pointer = right_pointer
    # Смотрим на следующий элемент
    right_pointer += 1

