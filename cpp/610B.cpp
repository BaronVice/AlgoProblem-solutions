/* Идея задачи: мы знаем, что гарантированно можно закрасить n * min_el квадратов,
где n - количество банок с краской, min_el - минимальный объем из этих банок.
Чтобы закрасить больше квадратов, нужно начинать с элемента правее минимума.
Тогда в случае с одним элементом можно закрасить на n-1 больше квадратов и получить
максимальный результат. Но когда минимумов больше одного, то среди них предстоит найти участок
наибольшей длины и прибавить его к количеству гарантированно закрашенных квадратов (n * min_el) */

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;
using ll = long long;

// Функция поиска максимальной длины сегмента 
int longest_segment(vector<ll> &array, int n, ll el){
    // Изначально самый длинный сегмент равен нулю
    int longest = 0;
    // Запоминаем первое вхождение, чтобы знать откуда начинать
    int first_occurence = find(array.begin(), array.end(), el) - array.begin();
    // Также для вычисления отрезка будем хранить его начало
    int previosly_found = first_occurence;

    // От следующего элемента первого вхождения и до конца
    for (int i = first_occurence + 1; i < n; i++){
        // Если нашли еще один минимум
        if (array[i] == el){
            // То вычисляем его длину
            int current_length = i - previosly_found - 1;
            // И если его длина больше текущего максимального, то мы нашли новую наибольшую длину
            longest = max(current_length, longest);
            // Теперь i будет последним втреченным минимумом
            previosly_found = i;
        }
    }

    /* Считаем длину отрезка от последнего элемента до первого встреченного
    (т.е. количество элементов от начала отрезка до первого встреченного минимума
    и от последнего встреченного минимума до конца отрезка. Так в случае с одним минимумом
    это и будет ответом, который можно представить как n-1) */
    int last_to_first_case = first_occurence + n - previosly_found - 1;

    // В зависимости от того, какой отрезок длинее, выводим его
    return max(longest, last_to_first_case);
}


int main(){
    int n;
    cin >> n;

    vector<ll> cans(n);
    ll min_el = 1000000000;
    for (auto &i: cans){
        cin >> i;
        min_el = min(i, min_el);
    }

    /* Минимальный элемент определяет максимальное количество обходов,
    Поэтому считаем количество закрашенных квадратов исходя из:
    Количества обходов и максимальной длины сегмента между минимальными элементами */
    cout << n * min_el + longest_segment(cans, n, min_el);


    return 0;
}