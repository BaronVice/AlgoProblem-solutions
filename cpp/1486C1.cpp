// https://codeforces.com/contest/1486/problem/C1

/*
Что надо сделать: найти максимальный индекс массива

Что знаем: количество элементов в массиве (элементы которого мы не знаем, но нам и не надо)

Что можем: делать запросы вида "? l r" для получения индекса второго максимума

Идея задачи:
1. Скажем, что [l, r] - отрезок, на котором будет находиться максимум.
2. Тогда узнаем, где находится второй максимум запросом "? l r" (отрезок, который рассматриваем)
Скажем, что второй максимум находится в первой половине

 Здесь
   |
----------|----------
3. Узнаем, где находится максимум. Проверить это можно так: если второй максимум отрезка находится на отрезке [l, mid),
тогда если при запросе "? l mid-1" получим ответ равный второму максимуму -> максимум также в первой половине (r = mid); иначе
получаем число меньше второго максимума, что означает максимум во второй половине (l = mid).

- Если в пункте 2 второй максимум во второй половине, то в пункте 3 рассматриваем как во второй половине

4. Делаем так, пока не останется два элемента, из которых за один запрос можно найти максимум
*/


#include <bits/stdc++.h>
using namespace std;

int ask(int l, int r){
    // На случай, если осталось два элемента в отрезке -> половины содержат по одному элементу (такой запрос делать нельзя)
    if (l == r) return -1;

    cout << "? " << l << ' ' << r << endl;
    int smax; cin >> smax;
    return smax;
}

int main(){
    int n; cin >> n;

    int l = 1, r = n;
    while (l + 1 < r){
        int smax = ask(l, r);
        int mid = (l + r) / 2;
        if (smax < mid){
            if (ask(l, mid-1) == smax){
                r = mid;
            } else {
                l = mid;
            }
        } else {
            if (ask(mid, r) == smax){
                l = mid;
            } else {
                r = mid;
            }
        }
    }

    // Из двух по позиции второго максимума можно определить максимум
    int smax = ask(l, r);
    if (smax == l){
        cout << "! " << r << endl;
    } else {
        cout << "! " << l << endl;
    }

    return 0;
}
