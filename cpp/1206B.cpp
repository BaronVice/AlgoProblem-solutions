/* Полагаю очевиден тот момент, что для получения результата произведения = 1 нужно свести все числа
либо к 1, либо к -1. Также нужно учесть, что в таком случае количество -1 должно быть четным
(минус на минус дает плюс). Нули будем обращать либо в 1, либо в -1 */

#include <iostream>

using namespace std;
using ll = long long;

int main(){
    cin.tie(0);
    cout.tie(0);
    ios_base::sync_with_stdio(0);

    int n;
    cin >> n;
    // Нам не важно количество положительных чисел, они не влияют на знак произведения
    int negative = 0, nills = 0;
    ll coins = 0, el;

    for (int i = 0; i < n; i++){
        cin >> el;
        // Если число положительное, то считаем сколько монет нужно для сведения к 1
        if (el > 0){
            coins += el - 1;
        }
        // Если число отрицательное, то считаем сколько монет нужно для сведения к -1
        else if (el < 0){
            negative++;
            coins -= el + 1;
        }
        // Если 0, то его нужно привести либо к 1, либо к -1
        else{
            nills++;
            coins++;
        }
    }
    // Если количество отрицательных четно, то все хорошо, выводим coins
    // Если нечетно, но у нас есть хотя бы один 0 для сведения к -1, то опять же выводим coins
    if (negative % 2 == 0 || nills > 0)
        cout << coins << '\n';
    // Иначе придется привести одну из -1 к 1, на что уйдет еще 2 монеты
    else
        cout << coins + 2 << '\n';

    return 0;
}