/* Идея задачи: у нас есть формула по которой можно определить, сколько строк кода при значении V
n строк будет напечатано. Однако если делать линейный перебор, то при больших n (в задаче n может
достигать 10**9 или 1000000000) такое решение будет вычислять ответ очень долго. Поэтому значения
будем подбирать бинарным поиском и подставлять в формулу. */

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;
// Функция, в которой будем определять, сколько строк кода можно напечатать при выбранном V
long long countLines(long long picked_v, long long k) {
    // Изначально Вася пишет V строк кода
    long long result = picked_v;
    // Но дальше он будет уставать
    long long power_of_k = k;
    // Пока он не уснет (т.е. пока он может писать больше нуля строк)
    while (picked_v / power_of_k > 0) {
        // К результату прибавляем значение по формуле
        result += picked_v / power_of_k;
        // Степень усталости увеличивается
        power_of_k *= k;
    }
    return result;
}
     
int main() {

    long long n, k;
    cin >> n >> k;
    // Левая граница - минимальное значение,
    // Правая - максимальное (если V = n, то Вася гарантированно напишет n срок кода)
    long long left = 0, right = n, mid;
    while (left + 1 < right) {
        mid = (left + right) / 2;
        // Если при выбранном mid получилось достигнуть n (или даже больше) строк кода, то
        if (countLines(mid, k) >= n) {
            // При mid Вася гарантированно напишет n строк кода, будем пробовать брать меньшие значения
            right = mid;
        }
        else {
            // Иначе n строк кода не достигнуто. Пробуем брать большие значения
            left = mid;
        }
    }
    // right - последнее вычисленное (т.е. минимальное) значение,
    // при котором Вася гарантированно напишет n строк
    cout << right;
    
    return 0;
}