""" Дерево отрезков - структура данных в виде двоичного дерева. Позволяет за логарифм времени реализовывать ассоциативные операции
(те, что не зависят от последовательности выполнения), у которых есть нейтральный элемент (1 для умножения, 0 для суммы, ...).
К таким операциям можно отнести сумму чисел, поиск минимума, перемножение матриц, поиск НОД, ...
По памяти сложность линейная (n на основной массив, еще n на остальное дерево: 2n -> n)

Здесь реализация красивого кода. Быстрый упирается в индексы на массиве, его реализуем позже """

result = 0

#   Значит у вершины есть отрезок, за который она отвечает (от l до r), значение оператора (op), значение результата на отрезке (val)
# ссылки на детей, которые отвечают за подотрезки текущей вершины (left_child - левая половина, right_child - правая половина)
class Node:
    def __init__(self, left, right, val, op=1, left_child=None, right_child=None):
        self.left = left
        self.right = right
        self.val = val
        self.op = op
        self.left_child: Node = left_child
        self.right_child: Node = right_child


#   propagate - проталкивание оператора детям. Используем тогда, когда понадобилась ветка. Спускаем значение оператора детям,
# меняем значение детей в соответствии с оператором, оператор родителя вернем к нейтральному элементу.
#   О том, зачем что-то проталкивать рассмотрим далее
def propagate(node: Node):
    #   У элементов массива (они же листья дерева - самые нижние элементы) нет детей, поэтому проверям, что мы не делаем
    # проталкивание в не существующий элемент
    if node.left_child is not None:
        node.left_child.val *= node.op
        node.left_child.op *= node.op
    if node.right_child is not None:
        node.right.val *= node.op
        node.right.op *= node.op
    node.op = 1

#   update - когда нас просят обновить значения на отрезке. Начиная с корня дерева будем рекурсивно спускаться вниз,
# делать проталкивание до тех пор, пока не встанем в узел, который полностью отвечает за отрезок. Затем рекурсивно пойдем наверх,
# пересчитывая верхние значения (меняются значения детей - меняются и значения родителей, поэтому родителей надо пересчитать)
#   Элементы ниже узла обновлять не будем, поскольку нас об этом пока не просят да и на это уйдет определенное количество операций.
# Вот когда попросят, тогда обновим, сделав проталкивание оператора до нужного отрезка (для этого и нужен propagate). Такой подход
# называется lazy propagation (ленивое проталкивание)
def update(left, right, x, node):
    propagate(node)
    #   Здесь отрезок никак не пересекается с изменяемым, нам он не интересен - делаем return
    if node.left >= right or node.right <= left:
        return
    #   В этом случае отрезок полностью лежит в изменяемом и в нем хранится результат отрезка, за который он отвечает.
    # Дальше мы не хотим тратить компьют на изменение детей (нас пока не просят), меняем значение и оператор
    # этой вершины и сделаем return
    if node.left >= left and node.right <= right:
        node.val *= x
        node.op *= x
        return
    # Иначе отрезок пересекается, но что менять непонятно - спускаемся в подотрезки (детей) и смотрим на их
    update(left, right, x, node.left_child)
    update(left, right, x, node.right_child)
    # После того, как дети обновились, пересчитаем родителей
    node.val = node.right_child + node.left_child


#   update - когда нас просят получить результат на отрезке. Начиная с корня дерева будем рекурсивно спускаться вниз,
# делать проталкивание до тех пор, пока не встанем в узел, который полностью отвечает за отрезок.
def get_result(left, right, node: Node):
    global result
    propagate(node)
    #   Здесь отрезок никак не пересекается с искомым, нам он не интересен - делаем return
    if node.left >= right or node.right <= left:
        return
    #   В этом случае отрезок полностью лежит в искомом и в нем хранится результат отрезка, за который он отвечает.
    # Поэтому дальше спускаться смысла нет, прибавим значение вершины к результату и сделаем return
    if node.left >= left and node.right <= right:
        result += node.val
        return
    #   Иначе отрезок пересекается, но точно сказать значение за пересечение не получится - спускаемся в подотрезки (детей) и там уже
    # рассматриваем их
    get_result(left, right, node.left_child)
    get_result(left, right, node.right_child)


def main():
    # Здесь еще нужна инициализация дерева отрезков, но в этой реализации главное понять как ДО работает.
    # Поэтому инициализацию рассмотрим в более быстрой реализации
    ...


if __name__ == "__main__":
    main()