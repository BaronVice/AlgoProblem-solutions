#include <iostream>

/* Дерево отрезков - структура данных в виде двоичного дерева. Позволяет за логарифм времени реализовывать ассоциативные операции
(те, что не зависят от последовательности выполнения), у которых есть нейтральный элемент (1 для умножения, 0 для суммы, ...).
К таким операциям можно отнести сумму чисел, поиск минимума, перемножение матриц, поиск НОД, ...
По памяти сложность линейная (n на основной массив, еще n на остальное дерево: 2n -> n)

Здесь реализация красивого кода. Быстрый упирается в индексы на массиве, его реализуем позже */

using namespace std;

int result;

/* Значит у вершины есть отрезок, за который она отвечает (от l до r), значение оператора (op), значение результата на отрезке (val)
ссылки на детей, которые отвечают за подотрезки текущей вершины (left_child - левая половина, right_child - правая половина) */
struct Node
{
    int l, r, op, val;
    Node* left_child;
    Node* right_child;
};

/* propagate - проталкивание оператора детям. Используем тогда, когда понадобилась ветка. Спускаем значение оператора детям,
меняем значение детей в соответствии с оператором, оператор родителя вернем к нейтральному элементу.
   О том, зачем что-то проталкивать рассмотрим далее */
void propagate(Node* node){
    /* У элементов массива (они же листья дерева - самые нижние элементы) нет детей, поэтому проверям, что мы не делаем
    проталкивание в не существующий элемент */
    if (node->left_child != nullptr){
        node->left_child->val *= node->op;
        node->left_child->op *= node->op;
    }
    if (node->right_child != nullptr){
        node->right_child->val *= node->op;
        node->right_child->op *= node->op;
    }
    node->op = 1;
}

/* update - когда нас просят обновить значения на отрезке. Начиная с корня дерева будем рекурсивно спускаться вниз,
делать проталкивание до тех пор, пока не встанем в узел, который полностью отвечает за отрезок. Затем рекурсивно пойдем наверх,
пересчитывая верхние значения (меняются значения детей - меняются и значения родителей, поэтому родителей надо пересчитать)
   Элементы ниже узла обновлять не будем, поскольку нас об этом пока не просят да и на это уйдет определенное количество операций.
Вот когда попросят, тогда обновим, сделав проталкивание оператора до нужного отрезка (для этого и нужен propagate). Такой подход
называется lazy propagation (ленивое проталкивание) */
void update(int left, int right, int x, Node* node){
    propagate(node);
    // Здесь отрезок никак не пересекается с изменяемым, нам он не интересен - делаем return
    if (node->l >= right || node->r <= left)
        return;
    // В этом случае отрезок полностью лежит в изменяемом и в нем хранится результат отрезка, за который он отвечает.
    // Дальше мы не хотим тратить компьют на изменение детей (нас пока не просят), меняем значение и оператор
    // этой вершины и сделаем return
    if (node->l >= left && node->r <= right){
        node->op *= x;
        node->val *= x;
        return;
    }
    // Иначе отрезок пересекается, но что менять непонятно - спускаемся в подотрезки (детей) и смотрим на их
    get_result(left, right, node->left_child);
    get_result(left, right, node->right_child);
    // После того, как дети обновились, пересчитаем родителей
    node->val = node->left_child->val + node->right_child->val;
}

/* update - когда нас просят получить результат на отрезке. Начиная с корня дерева будем рекурсивно спускаться вниз,
делать проталкивание до тех пор, пока не встанем в узел, который полностью отвечает за отрезок. */
void get_result(int left, int right, Node* node){
    propagate(node);
    // Здесь отрезок никак не пересекается с искомым, нам он не интересен - делаем return
    if (node->l >= right || node->r <= left)
        return;
    // В этом случае отрезок полностью лежит в искомом и в нем хранится результат отрезка, за который он отвечает.
    // Поэтому дальше спускаться смысла нет, прибавим значение вершины к результату и сделаем return
    if (node->l >= left && node->r <= right){
        result += node->val;
        return;
    }
    // Иначе отрезок пересекается, но точно сказать значение за пересечение не получится - спускаемся в подотрезки (детей) и там уже
    // рассматриваем их
    get_result(left, right, node->left_child);
    get_result(left, right, node->right_child);
}


int main(){
    
    // Здесь еще нужна инициализация дерева отрезков, но в этой реализации главное понять как ДО работает.
    // Поэтому инициализацию рассмотрим в более быстрой реализации

    return 0;
}