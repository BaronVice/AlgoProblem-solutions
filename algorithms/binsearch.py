""" Здесь реализован бинпоиск для определения индекса искомого элемента в массиве.
Например: есть массив [1, 14, 24, 24, 77, 79, 81, 92]. Хотим найти индекс 79 - получаем 5.
На запрос 99 получим -1 (поскольку такого элемента нет). На 24 тут либо 2, либо 3 (их здесь два экземпляра) """

from bisect import *


def bin_search(array: list, n: int, x: int):
    # Сперва определим границы поиска и где будет лежать ответ (индекс).
    # Скажу, что ответ будет в правой границе (right).
    # Тогда left = -1 (чтобы right мог дойти до 0).
    # right = n-1 (это индекс последнего элемента).
    left, right = -1, n-1
    # Пока left и right не находятся рядом друг с другом (left + 1 < right).
    while left + 1 < right:
        # Тыкаем в середину.
        mid = (left + right) // 2
        # Если элемент на выбранной позиции меньше искомого значения, то
        # откидываем левую половину, переместив левую границу к середине.
        if array[mid] < x:
            left = mid
        # Иначе элемент больше или РАВЕН тому, что мы ищем.
        # Тогда откидываем правую половину - правую границу ставим на середину.
        else:
            right = mid
    
    # Элемента может и не быть в массиве, поэтому сделаем проверку:
    # Существует - вернем индекс. Не существует - -1.
    return right if array[right] == x else -1


def main():
    # В python есть встроенный поиск на массивах - bisect_left и bisect_right.
    # У них общая задача: предполагается, что у нас есть отсортированный массив array и элемент x. 
    # Мы хотим поставить элемент x в array так, чтобы сохранить упорядоченность array. Для этого
    # нужно знать, на какой индекс делать вставку (.insert()).
    # Например array = [9, 12, 15, 18, 20, 20, 20]. Пусть x = 14, тогда оба bisecta скажут 2:
    # 14 нужно поставить на второй индекс, чтобы сохранить упорядоченность - [9, 12, ->14, 15, 18, 20, 20, 20]

    # А теперь про их отличие. Пусть x = 20, тогда bisect_left вернет 4, а bisect_right вернет 8. 
    # Почему так?
    # Дело в том, что в bisect_left ставит элемент, чтобы сохранилась упорядоченность, но при наличии одиннаковых
    # по значению элементов вставка будет осуществлена слева (как следует из названия) от равных элементов.
    # У bisect_right же наоборот - при наличии одиннаковых по значению элементов вставка будет осуществлена справа
    # (опять же исходя из названия) от равных элементов.

    # Для использования бисектов нужно их импортировать из библиотеки bisect - from bisect import *
    # P.S. * - импорт вообще всего, что содержится в пакете

    array = [9, 12, 15, 18, 20, 20, 20]
    print("Bisects:")
    # Сперва массив, затем элемент
    print(bisect_left(array, 14))
    print(bisect_right(array, 14))

    print(bisect_left(array, 20))
    print(bisect_right(array, 20))

    print("Binsearch:")
    print(bin_search(array, len(array), 9))
    print(bin_search(array, len(array), 20))
    print(bin_search(array, len(array), 18))
    print(bin_search(array, len(array), 69))
    print(bin_search(array, len(array), 13))


if __name__ == "__main__":
    main()
